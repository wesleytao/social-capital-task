for (j in 1:ncol(X)){
thisorder  <-order(X[,j])
sort_y     <-cumsum(value[thisorder])
print(sort_y)
split      <-which.max(sort_y)
index      <-thisorder[split]
threshold[j]  <-X[index,j]
}
# print(threshold)
out_j<-which.max(threshold)
theta<-threshold[out_j]
return(c(out_j,theta,1))
}
n=nrow(mydata)
train(mydata[1:n,-ncol(mydata)],rep(1,n)/n,mydata[1:n,ncol(mydata)])
train<-function(X,w,y){
#   where X is a matrix the columns of
# which are the training vectors x(1); : : : ; x(n), and w and y are vectors containing the weights and class
# labels.
# The output pars is a list which contains the parameters specifying the resulting classifier.
# for each dimension of X
value<-w*y
# j dimension
threshold<-rep(NA,ncol(X))
for (j in 1:ncol(X)){
thisorder  <-order(X[,j])
sort_y     <-cumsum(value[thisorder])
split      <-which.max(sort_y)
print(split)
index      <-thisorder[split]
threshold[j]  <-X[index,j]
}
# print(threshold)
out_j<-which.max(threshold)
theta<-threshold[out_j]
return(c(out_j,theta,1))
}
n=nrow(mydata)
train(mydata[1:n,-ncol(mydata)],rep(1,n)/n,mydata[1:n,ncol(mydata)])
train<-function(X,w,y){
#   where X is a matrix the columns of
# which are the training vectors x(1); : : : ; x(n), and w and y are vectors containing the weights and class
# labels.
# The output pars is a list which contains the parameters specifying the resulting classifier.
# for each dimension of X
value<-w*y
# j dimension
threshold<-rep(NA,ncol(X))
for (j in 1:ncol(X)){
thisorder  <-order(X[,j])
sort_y     <-cumsum(value[thisorder])
split      <-which.max(sort_y)
# print(split)
index      <-thisorder[split]
print(index)
threshold[j]  <-X[index,j]
}
# print(threshold)
out_j<-which.max(threshold)
theta<-threshold[out_j]
return(c(out_j,theta,1))
}
n=nrow(mydata)
train(mydata[1:n,-ncol(mydata)],rep(1,n)/n,mydata[1:n,ncol(mydata)])
?gbm
??gbm
install.packages(gbm)
install.packages("gbm")
install.packages("ada")
?ada
??ada
data(iris)
##drop setosa
iris[iris$Species!="setosa",]->iris
##set up testing and training data (60% for training)
n<-dim(iris)[1]
trind<-sample(1:n,floor(.6*n),FALSE)
teind<-setdiff(1:n,trind)
iris[,5]<- as.factor((levels(iris[,5])[2:3])[as.numeric(iris[,5])-1])
##fit 8-split trees
gdis<-ada(Species~.,data=iris[trind,],iter=20,nu=1,type="discrete")
library(ada)
##fit 8-split trees
gdis<-ada(Species~.,data=iris[trind,],iter=20,nu=1,type="discrete")
##add testing data set
gdis=addtest(gdis,iris[teind,-5],iris[teind,5])
##plot gdis
plot(gdis,TRUE,TRUE)
##variable selection plot
varplot(gdis)
##pairwise plot
pairs(gdis,iris[trind,-5],maxvar=2)
##variable selection plot
varplot(gdis)
head(gdis)
head(iris)
# adaboost for variable importance
library(adaboost)
# adaboost for variable importance
library(ada)
library(dplyr)
library(ggplot2)
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
var_des     <-Census_data[1,] # store description
Census_data <-Census_data[-1,-1] # rest of the data,drop the first column and first row
rate_2014$id          <- as.integer(rate_2014$id) # we need to convert to integer for combining data
Census_data$GEO.id2   <- as.integer(Census_data$GEO.id2)
names(rate_2014)      <- c("GEO.id2","SK14") # rename the label
states<-regmatches(Census_data$GEO.display.label,regexpr(pattern = ", [A-Z]+[a-z]+",text=Census_data$GEO.display.label))
states<-as.factor(substr(states,3,nchar(states)))
Census_data$GEO.display.label<-states
county<-gsub(",.*$", "", Census_data$GEO.display.label)
Census_data$county<-county
newdata<-rate_2014 %>%
left_join(Census_data,by="GEO.id2") #combine two table
head(newdata)
newdata<-na.omit(newdata)
var_des[4]
pop<-as.numeric(newdata$HC01_VC03) # this variable is the population estimate
length(pop)
X_index     <-X_index[-1] # remove the first HC03_VC_03
X_pattern       <-"HC03_VC[0-9]+"# regular expression
newdata_colnames<-names(newdata)
X_index         <-grep(X_pattern,newdata_colnames)
head(newdata_colnames[X_index],10) # but HC03_VC_03 is the population
X_index
X_index     <-X_index[-1] # remove the first HC03_VC_03
y_index     <-2
subset_index<-c(y_index,X_index) # combine with y
newdata<-apply(newdata[,subset_index],2,as.numeric)# these '(X)' will be automatically handled by as.integer and replaced by NA
nrow(newdata)
# head(newdata)
nrow(newdata)
length(pop)
nrow(newdata)==length(pop)
head(newdata)
# head(scaled_data)
ncol(scaled_data)
?scaled
?scale
require(stats)
x <- matrix(1:10, ncol = 2)
(centered.x <- scale(x, scale = FALSE))
x
(centered.x <- scale(x, scale = FALSE))
x
(centered.x <- scale(x, scale = FALSE))
cov(centered.scaled.x <- scale(x)) # all 1
library(dplyr)
library(ggplot2)
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
var_des     <-Census_data[1,] # store description
Census_data <-Census_data[-1,-1] # rest of the data,drop the first column and first row
rate_2014$id          <- as.integer(rate_2014$id) # we need to convert to integer for combining data
Census_data$GEO.id2   <- as.integer(Census_data$GEO.id2)
names(rate_2014)      <- c("GEO.id2","SK14") # rename the label
states<-regmatches(Census_data$GEO.display.label,regexpr(pattern = ", [A-Z]+[a-z]+",text=Census_data$GEO.display.label))
states<-as.factor(substr(states,3,nchar(states)))
Census_data$GEO.display.label<-states
county<-gsub(",.*$", "", Census_data$GEO.display.label)
Census_data$county<-county
newdata<-rate_2014 %>%
left_join(Census_data,by="GEO.id2") #combine two table
X_pattern       <-"HC03_VC[0-9]+"# regular expression
newdata_colnames<-names(newdata)
X_index         <-grep(X_pattern,newdata_colnames)
head(newdata_colnames[X_index],10) # but HC03_VC_03 is the population
newdata<-na.omit(newdata)
var_des[4]
pop<-as.numeric(newdata$HC01_VC03) # this variable is the population estimate
# X_index    <-X_index[-1] # remove the first HC03_VC_03
y_index     <-2
subset_index<-c(y_index,X_index) # combine with y
newdata.subset<-apply(newdata[,subset_index],2,as.numeric)# these '(X)' will be automatically handled by as.integer and replaced by NA
# head(newdata.subset)
# it seems that we also have some variables which are population labor force, we have to get rid of them too
# rules are if value is larger than 200 then
pop<-newdata
log.index<-apply(newdata.subset,2,mean,na.rm=T)<200
new_index<-which(log.index)
cleaned_data<-newdata.subset[,new_index]
cleaned_data<-na.omit(cleaned_data) # omit na by row
# split the data for train and test
# 20% of the data as test data and 80 % as train data
set.seed(1)
total.num      <-nrow(cleaned_data)
test_index_row <-sample(seq(total.num),total.num*0.2)
train_index_row<-setdiff(seq(total.num),test_index_row)
X_test<-cleaned_data[test_index_row,-1]
y_test<-cleaned_data[test_index_row,1]
X_train<-cleaned_data[train_index_row,-1]
y_train<-cleaned_data[train_index_row,1]
length(test_index_row)+length(train_index_row)==total.num # make sure the number meet
library(ggplot2)
library(reshape2)
cormat       <-round(cor(X_train),2)
melted_cormat<-melt(cormat) # transform to a narrow format
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) +
geom_tile()
# it seems that this data set has a lot of collinearity, It might cause a lot of problem, we need regularization
library(glmnet)
# 5-fold Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
set.seed(4)
alpha_seq<-seq(10)/10
result<-data.frame(alpha=alpha_seq,mse=rep(NA,length(alpha_seq)))# generate a data frame to store the result
for(i in 1:length(alpha_seq)){
this.alpha <-alpha_seq[i]
fit.reg.cv <- cv.glmnet(X_train, y_train,nfold=10, type.measure="mse", alpha=this.alpha,
family="gaussian")
this.lambda<-fit.reg.cv$lambda.min # we choose lambda with the minimun mse
yhat       <-predict(fit.reg.cv, s=this.lambda, newx=X_train) # get pred over the train set
mse        <- mean((y_train - yhat)^2) #compute mse
result[i,2]<-mse #
}
# plot mse over alpha
ggplot(data = result,aes(x=alpha,y=mse))+
geom_line()+
labs(title="Select Alpha based on cross-validation error")
set.seed(1)
fit.ela.cv <- cv.glmnet(X_train, y_train, type.measure="mse", alpha=0.9,
family="gaussian",nfolds = 5)
plot(fit.ela.cv)
yhat <- predict(fit.ela.cv, s=fit.ela.cv$lambda.1se, newx=X_test)
test_mse <- mean((y_test - yhat)^2)
plot(fit.ela.cv$glmnet.fit,"norm",label = T)
plot(fit.ela.cv$glmnet.fit,"lambda",label = T)
setwd("../figs") # set image path
png(filename = paste("coe path",".png",sep = ""))
plot(fit.ela.cv$glmnet.fit,"lambda",label = T)
dev.off()
split("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64")
strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64")
strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64".split=" ")
strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64".split=" ")
strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64",split=" ")
strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64",split="\n")
var<-strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64",split="\n")[[1]]
var
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
var_des     <-Census_data[1,] # store description
Census_data <-Census_data[-1,-1] # rest of the data,drop the first column and first row
rate_2014$id          <- as.integer(rate_2014$id) # we need to convert to integer for combining data
Census_data$GEO.id2   <- as.integer(Census_data$GEO.id2)
names(rate_2014)      <- c("GEO.id2","SK14") # rename the label
states<-regmatches(Census_data$GEO.display.label,regexpr(pattern = ", [A-Z]+[a-z]+",text=Census_data$GEO.display.label))
states<-as.factor(substr(states,3,nchar(states)))
Census_data$GEO.display.label<-states
county<-gsub(",.*$", "", Census_data$GEO.display.label)
Census_data$county<-county
newdata<-rate_2014 %>%
left_join(Census_data,by="GEO.id2") #combine two table
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
var_des     <-Census_data[1,] # store description
Census_data <-Census_data[-1,-1] # rest of the data,drop the first column and first row
rate_2014$id          <- as.integer(rate_2014$id) # we need to convert to integer for combining data
Census_data$GEO.id2   <- as.integer(Census_data$GEO.id2)
names(rate_2014)      <- c("GEO.id2","SK14") # rename the label
states<-regmatches(Census_data$GEO.display.label,regexpr(pattern = ", [A-Z]+[a-z]+",text=Census_data$GEO.display.label))
states<-as.factor(substr(states,3,nchar(states)))
Census_data$GEO.display.label<-states
county<-gsub(",.*$", "", Census_data$GEO.display.label)
Census_data$county<-county
newdata<-rate_2014 %>%
left_join(Census_data,by="GEO.id2") #combine two table
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
getwd()
# head(newdata)
getwd()
setwd("C:/Users/Wesle/Documents/GitHub/social-capital-task/lib")
Census_data <-read.csv("../data/Census data with variables 2016.csv",header = T,sep=",",as.is = T)
rate_2014   <-read.table("../output/rate_2014.tsv",header=T) # first row seems to be the description of the variable
var_des     <-Census_data[1,] # store description
Census_data <-Census_data[-1,-1] # rest of the data,drop the first column and first row
rate_2014$id          <- as.integer(rate_2014$id) # we need to convert to integer for combining data
Census_data$GEO.id2   <- as.integer(Census_data$GEO.id2)
names(rate_2014)      <- c("GEO.id2","SK14") # rename the label
states<-regmatches(Census_data$GEO.display.label,regexpr(pattern = ", [A-Z]+[a-z]+",text=Census_data$GEO.display.label))
states<-as.factor(substr(states,3,nchar(states)))
Census_data$GEO.display.label<-states
county<-gsub(",.*$", "", Census_data$GEO.display.label)
Census_data$county<-county
newdata<-rate_2014 %>%
left_join(Census_data,by="GEO.id2") #combine two table
head(newdata)
head(newdata,3)
nrow(newdata)
rownames(newdata)
colnames(newdata)
var_X
var_X<-strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC64",split="\n")[[1]]
var_X
var_y<-"SK14"
filter_data<-newdata[,c(var_y,"county",var_X)]
c(var_y,"county",var_X)
filter_data<-newdata[,c("county",var_X)]
filter_data<-newdata[,var_X]
c(var_y,"county",var_X)
filter_data<-newdata[,"HC03_VC07"]
filter_data<-newdata[,c("HC03_VC07",var_X)]
filter_data<-newdata[,var_y]
filter_data<-newdata[,c(var_y,var_X)]
var_X<-strsplit("HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC164",split="\n")[[1]]
filter_data<-newdata[,c(var_y,"county",var_X)]
head(filter_data)
nrow(pop)
nrow(filter_data)
var_X<-strsplit("HC01_VC03
HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC164",split="\n")[[1]]
filter_data<-newdata[,c(var_y,"county",var_X)]
head(filter_data)
write.csv(filter_data,"Interesting_vars_based_on_lasso.csv")
# need to classify each class
class<-ifelse(filter_data$SK14>0,1,-1)
summary(class)
filter_data$class<-class
summary(filter_data)
head(filter_data)
"HC03_VC131
HC03_VC132
HC03_VC134",split="\n")[[1]]
strsplit("HC03_VC131 HC03_VC132 HC03_VC134",split=" ")[[1]]
insurance_var<-strsplit("HC03_VC131 HC03_VC132 HC03_VC134",split=" ")[[1]]
filter_data[,insurance_var]/filter_data$HC01_VC03
as.numeric(filter_data[,var_X])
apply(filter_data[,var_X],2,as.numeric)
head(cbind(filter_data[,c(var_y,"county")],X))
X<-apply(filter_data[,var_X],2,as.numeric)
head(cbind(filter_data[,c(var_y,"county")],X))
filter_data<-cbind(filter_data[,c(var_y,"county")],X)
filter_data[,insurance_var]/filter_data$HC01_VC03
(filter_data[,insurance_var]/filter_data$HC01_VC03)*filter_data$HC01_VC03==filter_data[,insurance_var]
modified_insurance<-(filter_data[,insurance_var]/filter_data$HC01_VC03)
filter_data[,c("HC03_VC131_m","HC03_VC132_m","HC03_VC134")]<-modified_insurance
colnames(newdata)
var_y<-"SK14"
var_X<-strsplit("HC01_VC03
HC03_VC07
HC03_VC23
HC03_VC50
HC03_VC69
HC03_VC101
HC03_VC131
HC03_VC132
HC03_VC134
HC03_VC164",split="\n")[[1]]
filter_data<-newdata[,c(var_y,"county",var_X)]
X<-apply(filter_data[,var_X],2,as.numeric)
filter_data<-cbind(filter_data[,c(var_y,"county")],X)
# need to classify each class
class<-ifelse(filter_data$SK14>0,1,-1)
summary(class)
filter_data$class<-class
insurance_var<-strsplit("HC03_VC131 HC03_VC132 HC03_VC134",split=" ")[[1]]
modified_insurance<-(filter_data[,insurance_var]/filter_data$HC01_VC03)
filter_data[,c("HC03_VC131_m","HC03_VC132_m","HC03_VC134_m")]<-modified_insurance
head(filter_data)
write.csv(filter_data,"Interesting_vars_based_on_lasso.csv")
str(filter_data)
filter_data$county<-as.factor(filter_data$county)
colnames(filter_data)!%in% insurance_var
colnames(filter_data)%in% insurance_var
!colnames(filter_data)%in% insurance_var
ada<-ada(class~.,data=filter_data[,!colnames(filter_data)%in% insurance_var],iter=20,nu=1,type="discrete")
thisada<-ada(class~.,data=filter_data[,!colnames(filter_data)%in% insurance_var],iter=20,nu=1,type="discrete")
plot(thisada)
plot(thisada,T,T)
varplot(thisada)
thisada<-ada(class~.,data=filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14")],iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14","HC01_VC_03")],iter=20,nu=1,type="discrete")
varplot(thisada)
data_forada<-filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14","HC01_VC_03")]
rownames(data_forada)
names(data_forada)
names(data_forada)
thisada<-ada(class~.,data=,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
plot(thisada,T,T)
varplot(thisada)
plot(thisada,T,T)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
data_forada<-filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14","HC01_VC03")]
names(data_forada)
names(data_forada)<-c("states","")
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
data_forada<-filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14","HC01_VC03")]
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
varplot(thisada)
plot(thisada,T,T)
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
data_forada<-filter_data[,!colnames(filter_data)%in% c(insurance_var,"SK14","HC01_VC03")]
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
names(data_forada)
names(data_forada)
names(data_forada)<-c("states","Unemployment_Rate","Both_Parents_working","Hunting_fishing_industry","Self-employed","FoodStamp",
"Poverty_level","class","Public_insurance_coverage_modified","private_insurance_coveraged_modified","no_health_insurance")
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
thisada<-ada(class~.,data=data_forada,iter=20,nu=1,type="discrete")
varplot(thisada)
